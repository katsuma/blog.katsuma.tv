---
title: ハードウェアが特定の条件下ではIEでfilter:alpha(opacity=N)が適用されない
date: 2011/03/07
tags: css
published: true

---

 <p>CSSでDOM要素に対してアルファフィルターを適用させたいときは、クロスブラウザを意識すると次のような記述になると思います。
   もうすこし古いMozilla系ブラウザを対象にするなら-moz-opacityの定義も追加してあげるとことになりますが、
   今回はIEに絞った話のため、そのあたりは割愛します。
 </p>

 <p><pre>
#element {
  filter: alpha(opacity=0); /* IE */
  opacity: 0; /* その他のモダンブラウザ */
}
</pre></p>

 <p>さて、普段は特に何も考えずにfilter:alpha~と記述していたのですが、
   実はIEはある条件下によってまったくfilterが効かない場合があります。</p>

 <h3>ActiveXが無効</h3>
 <p>そもそもの話ですが、filterはActiveXを利用したレンダリングを行っています。
   そのため、そもそもセキュリティの設定などでActiveXを無効にされていると、filterが効かず想定したようなレンダリングがされません。</p>
 <p>たとえば、「インターネットオプション」の「セキュリティ」でセキュリティのレベルを「高」にする、ActiveXの設定を個別でOFFにする、
   などの設定を行うなどでfilterを無効にすることができます。</p>
 <p><img src="http://gyazo.com/80fed404c3f6f7a032f5fe69b9a37941.png" alt="インターネットオプション" /></p>

 <p>ただし、この場合は当然ながらFlashも見ることはできませんし、セキュリティを気にするユーザはそもそもIE以外のモダンブラウザを利用することの方が多いでしょうし、
標準的なユーザがこの条件下でfilterが効かない、という話はほぼ無いと考えてもいいと思います。実は次の問題が厄介です。</p>

 <h3>2048pxを超えるような巨大な要素がfilterの対象</h3>
 <p>実は今回この事例にずばりハマってたのですが、</p>
<p>
 <ul>
   <li>IE7,8(6は未確認)</li>
   <li>Windows Vista, 7(XPは未確認)</li>
   <li>filter対象要素が2048pxを超えるような巨大なもの</li>
   <li>ATI(AMD), NVidiaのグラフィックカード</li>
</ul></p>
 <p>な条件下において、filterが適用されないことを確認しています。(<a href="http://social.msdn.microsoft.com/forums/en-US/iewebdevelopment/thread/29d0b0e7-4326-4b3e-823c-51420d4cf253/" target="_blank">参考文献 "filter-alpha-opacity fails if the element is taller than 2048px, IE7 Vista"</a>)</p>

 <p>上記のActiveX無効の場合はJavaScriptでActiveXが有効/無効を判断できるので、何らかの対応をすることはできるのですが、
   この場合はハードウェアの話が絡んでくるので、実質的な回避方法はありません。後で詳しく述べますが、今回は</p>
 <p>
   <ul>
	 <li>filter対象要素が2048pxを超えるような巨大なもの</li>
   </ul>
 </p>

 <p>をやめて、filter対象要素の面積を可能なかぎり小さくすることができたので、回避しました。</p>

 <h3>巨大な要素にfilterをかける必要性</h3>
 <p>そもそも、なんでそんな巨大な要素にfilterをかける必要があるのかという話になるのですが、今回はファイルアップロードのUIをゼロから作ったことに起因します。
   ファイルアップロードの際には、&lt;input type="file" name="uploader" /&gt;なんかでファイル選択ダイアログを表示し、対象ファイルを選択することになります。
   ところが、これはブラウザ標準のUIになるので、「もっと凝ったことしたい!画像など任意に要素クリックでこの選択ダイアログを表示させたい!」などとなると、途端に話は面倒くさくなり、</p>
 <p>
   <ol>
	 <li>Flashで実装</li>
	 <li>JavaScript/CSSで巧みに実装</li>
   </ol>
 </p>

 <p>の選択を迫られることになります。</p>

 <p>Flashで実装をとるという方法もあったのですが、カスタマイズ性や毎回publishすることの実装コストを考慮して、JS/CSSでの実装を選択することにしました。
   たとえば画像クリックでファイル選択ダイアログを表示させたい場合、次のような構成になります。</p>
 <p><img src="http://blog.katsuma.tv/images/upload-1.png?v1" /></p>
 <p>img要素の上に大きめのinput要素を重ねあわせ、filterでalpha=0に指定します。これで画像をクリックしようとするとinput要素をクリックすることになり、結果的にダイアログを表示することができます。
   そのあとはinput要素のchangeイベントに対してハンドラを設定し、formを送信なりなんなりとしてあげると完了です。</p>

 <p>ところが、ここで１つマウスカーソルの問題があります。ただ単純にinput要素を重ねただけだと、画像の上にカーソルを重ねたときに</p>
 <p><img src="http://gyazo.com/951cce6610efa70467ca700dfc8ce4d0.png" /></p>
 <p>な形状になり、クリックできそうなことを連想できません。そこで、input要素に対して</p>
 <p><pre>
cursor: pointer;
</pre></p>
 <p>な、スタイルを設定する必要があります。これでカーソルの形状が</p>
 <p><img src="http://gyazo.com/b70fc947973eff8acbbe5de331574b37.png" /></p>
 <p>になり、解決しました。。と、言いたいのですが、実はこれでもまだ完璧ではなく、Firefoxではカーソルは変わりません。</p>
 <p>どうもこれはFirefoxの仕様のようで、いくらcursor指定をしても変わることがありませんでした。では、Firefoxだけ残念な形になっちゃうのか。。と思いきやそうでもなく、先ほどの画像とinput要素の重ね方を工夫するともうすこし頑張れます。結果から言うとこう配置します。</p>

 <p><img src="http://blog.katsuma.tv/images/upload-2.png?v2" /></p>
 <p>分かりづらいですが、最初の例では画像に対してinput要素も{ left:0, top:0 }で配置していたのに比べて、２つ目の例ではinput要素をサイズを巨大なものにして、{ right:0, top:0 }で配置します。(大きさはfont-size:で調整します)
   このとき、<strong>要素のサイズを巨大にして「選択」ボタンを画像に重ねる</strong>ことがポイントです。「選択」ボタンを画像にうまく重ねることで、画像のマウスオーバー時に</p>
 <p><img src="http://gyazo.com/1a11e1ef315d505d5d92e5f354e72a1c.png" /></p>
 <p>と、することができ、最初の状態と比べて「クリックできそう感」が改善されます。ちなみにこのマニアックな手法はいろんなファイルアップロードライブラリを見ても、
Flash実装じゃないものは全部この仕様になってあり、Firefoxのマウスカーソル問題はここが妥協ポイントのようです。（例：<a href="https://github.com/valums/file-uploader">file-uploader</a>）</p>

 <h3>話をfilterに戻す</h3>
 <p>大きく脱線しましたが、ようやく最初のfilterの話に戻します。</p>
 <p>ここまできてようやく「Flashで実装しない場合に、ファイルアップロードを実装する場合において、カーソルの形状の最適化のためにfilter対象要素を十分に大きくする必要がある」という話になりました。実際にこれを実装してみるとわかるのですが、画像と選択ボタンを合わせるためにはinput要素を相当巨大なものにする必要があり、
   <strong>結果的に{数千px × 数百px}の巨大な面積の要素にfilterをかけることになります。</strong></p>

<p>
で、HWスペックが十分なマシンだとIEだと問題なくレンダリングされるのですが、冒頭の条件であったりレンダリングスペックが十分でない場合、filterに失敗して
表示が崩れる、という問題が起こります。

この場合、セキュリティ設定やActitiveXなどOS、ブラウザの設定を操作することなくfilterが無効になるので、気づかない間にユーザが不便を被ることになるので非常に厄介です。</p>

 <p>さて、ではどう対策をすればいいかというと、話を振り返るとそもそもinput要素を巨大にしたり右寄せにしたり面倒なことをしているのはFirefoxのマウスカーソルを
   いい感じに見せるためだけであって、IEはそもそもこの対応をしなくともcursor: pointer;だけしておけば表示位置はどこに設定してもOKなので、
<strong>IEだけレンダリング要素を最小化しておけば大丈夫</strong>という最初で述べた結論に帰着するのです。（長い！）</p>

<p>と、いうわけでここまでまとめるとたとえば130x130なサイズの画象にinput要素をかぶせるときは次のようなスタイルを設定します。サイズは各環境によって微調整をしてください。</p>

 <p><pre>
right: 0;
top: 0;
position: absolute;
cursor: pointer;
opacity: 0; /* IE以外の最新ブラウザはこれでOK */
filter: alpha(opacity=0); /* IE */
font-size: 460px;

/* StarHackを使ってIEだけ適用。要素を必要十分なサイズで最小化。 */
*font-size: 32px;
*width: 130px;

z-index: 1;
height: 130px;
</pre></p>

 <h3>結論</h3>
 <p><strong>CSSコーディングでグラフィックカードの特性を意識しないのは素人！</strong></p>

<h3>ところで</h3>
<p>今回はたまたまレンダリング要素のサイズ変更で回避できましたが、本質的な解決にはなっていません。あと動的なサイズの要素の場合、回避は不可能そうです。どなたかこの問題について詳しい方はいないでしょうかね？？</p>


